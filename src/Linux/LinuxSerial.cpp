// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#include <termios.h>
#include <chrono>
#include <iostream>
#include <iomanip>

#include "optional.h"
#include "LinuxSerial.h"
#include "IBaseLibrary.h"
#include "IDebug.h"

namespace EPRI
{
    //
    // LinuxSerial
    //
    LinuxSerial::LinuxSerial(asio::io_service& IO)
        : m_IO(IO)
    {
    }
    
    LinuxSerial::~LinuxSerial()
    {
    }
        
    ISerialSocket * LinuxSerial::CreateSocket(const ISerial::Options& Opt)
    {
        return &(*m_Sockets.emplace(m_Sockets.begin(), Opt, m_IO));
    }
    
    void LinuxSerial::ReleaseSocket(ISerialSocket * pSocket)
    {
        pSocket->Close();
        //
        // Post to allow socket cleanup befor removal.
        //
        m_IO.post(std::bind(&LinuxSerial::RemoveSocket, this, pSocket));
    }
    
    bool LinuxSerial::Process()
    {
        return true;
    }

    void LinuxSerial::RemoveSocket(ISerialSocket * pSocket)
    {
        m_Sockets.remove_if(
            [pSocket](const LinuxSerialSocket& Socket)
        {
            return &Socket == pSocket;
        });
    }    
    //
    // LinuxSerialSocket
    //
    LinuxSerialSocket::LinuxSerialSocket(const ISerial::Options& Opt, asio::io_service& IO)
        : m_Options(Opt)
        , m_Port(IO)
        , m_ReadTimer(IO)
    {
    }
    
    LinuxSerialSocket::~LinuxSerialSocket()
    {
    }

    void LinuxSerialSocket::ASIO_Write_Handler(const asio::error_code& Error, size_t BytesTransferred)
    {
        //
        // Handle Serial Disconnection
        //
        if ((asio::error::eof == Error) ||
            (asio::error::connection_reset == Error) ||
            (asio::error::operation_aborted == Error))
        {
            OnClose(SUCCESSFUL);
        }
        else if (m_Write)
        {
            m_Write(Error || !m_Port.is_open() ? !SUCCESSFUL : SUCCESSFUL, BytesTransferred);
        }
    }
    
    void LinuxSerialSocket::ASIO_Read_Handler(const asio::error_code& Error, size_t BytesTransferred)
    {
        // Port has been closed
        //
        if (asio::error::bad_descriptor == Error)
        {
            return;
        }
        // Got Data, cancel any timeouts
        //
        m_ReadTimer.cancel();
        //
        // Handle Serial Disconnection
        //
        if ((asio::error::connection_reset == Error) ||
            (asio::error::eof == Error))
        {
            OnClose(SUCCESSFUL);
        }
        else if (m_Read)
        {
            ERROR_TYPE ErrorCode = SUCCESSFUL;
            if (asio::error::operation_aborted == Error)
            {
                ErrorCode = ERR_TIMEOUT;
            }
            else if (Error)
            {
                printf("ERROR! %s\n", Error.message().c_str());
                ErrorCode = !SUCCESSFUL;
            }
            m_Read(ErrorCode, BytesTransferred);
        }
    }
    
    void LinuxSerialSocket::ASIO_Read_Timeout(const asio::error_code& Error)
    {
        if (asio::error::operation_aborted != Error)
        {
            m_Port.cancel();
        }
    }

    ERROR_TYPE LinuxSerialSocket::Open(const char * DestinationAddress /*= nullptr*/, int Port /*= DEFAULT_DLMS_PORT*/)
    {
        ERROR_TYPE RetVal = SUCCESSFUL;
        try
        {
            m_Port.open(DestinationAddress);
            SetPortOptions();
            Flush(EPRI::ISerialSocket::BOTH);
            if (m_Connect)
            {
                Base()->GetDebug()->TRACE("\n\nConnected to %s...\n\n",  
                    DestinationAddress);
                m_Connect(SUCCESSFUL);
            }
        }
        catch (asio::system_error& Error)
        {
            RetVal = !SUCCESSFUL;
        }
        return RetVal;
    }
    
    LinuxSerialSocket::ConnectCallbackFunction LinuxSerialSocket::RegisterConnectHandler(ConnectCallbackFunction Callback)
    {
        ConnectCallbackFunction RetVal = m_Connect;
        m_Connect = Callback;
        return RetVal;
    }
    
    ISerial::Options LinuxSerialSocket::GetOptions()
    {
        return m_Options;
    }
    
    ERROR_TYPE LinuxSerialSocket::Write(const DLMSVector& Data, bool Asynchronous /*= false*/)
    {
        asio::error_code SocketError;
        ERROR_TYPE       RetVal = SUCCESSFUL;

        Base()->GetDebug()->TRACE_VECTOR("SW", Data);
        
        if (Asynchronous)
        {
            if (m_Write)
            {
                asio::async_write(m_Port,
                    asio::buffer(Data.GetBytes()), 
                    std::bind(&LinuxSerialSocket::ASIO_Write_Handler, this, std::placeholders::_1, std::placeholders::_2));
            }
        }
        else
        {
            asio::write(m_Port, asio::buffer(Data.GetBytes()), asio::transfer_all(), SocketError);
            if (SocketError)
            {
                RetVal = !SUCCESSFUL;
            }
        }
        return RetVal;
    }
    
    LinuxSerialSocket::WriteCallbackFunction LinuxSerialSocket::RegisterWriteHandler(WriteCallbackFunction Callback)
    {
        WriteCallbackFunction RetVal = m_Write;
        m_Write = Callback;
        return RetVal;
    }
    
    ERROR_TYPE LinuxSerialSocket::Read(DLMSVector * pData,
        size_t ReadAtLeast /*= 0*/,
        uint32_t TimeOutInMS /*= 0*/,
        size_t * pActualBytes /*= nullptr*/)
    {
        ERROR_TYPE       RetVal = SUCCESSFUL;
        
        if (!pData /* Asynchronous */)
        {
            asio::async_read(m_Port,
                m_ReadBuffer,
                asio::transfer_exactly(ReadAtLeast ? ReadAtLeast : 1), 
                std::bind(&LinuxSerialSocket::ASIO_Read_Handler, this, std::placeholders::_1, std::placeholders::_2));
            if (TimeOutInMS)
            {
                m_ReadTimer.expires_from_now(std::chrono::milliseconds(TimeOutInMS));
                m_ReadTimer.async_wait(std::bind(&LinuxSerialSocket::ASIO_Read_Timeout,
                    this, 
                    std::placeholders::_1));
            }
            else
            {
                m_ReadTimer.cancel();
            }
        }
        else
        {
            size_t                         ActualBytes = 0;
            DLMSOptional<asio::error_code> TimerResult;
            asio::steady_timer             SynchronousTimer(m_Port.get_executor());
            SynchronousTimer.expires_from_now(std::chrono::milliseconds(TimeOutInMS));
            
            ActualBytes = asio::read(m_Port,
                m_ReadBuffer,
                asio::transfer_exactly(ReadAtLeast ? ReadAtLeast : 1));   
            if (ActualBytes)
            {
                if (!AppendAsyncReadResult(pData, ActualBytes))
                {
                    RetVal = !SUCCESSFUL; //TODO
                }
            }
            else 
            {
                RetVal = !SUCCESSFUL;
            }
        }
        return RetVal;  
    }
    
    bool LinuxSerialSocket::AppendAsyncReadResult(DLMSVector * pData, size_t ReadAtLeast /*= 0*/)
    {
        std::istream Stream(&m_ReadBuffer);
        if (0 == ReadAtLeast)
        {
            Stream.seekg(0, Stream.end);
            ReadAtLeast = Stream.tellg();
            Stream.seekg(0, Stream.beg);
        }
        uint8_t * pBuffer = &(*pData)[pData->AppendExtra(ReadAtLeast)];
        Stream.read((char *)pBuffer, ReadAtLeast);

        Base()->GetDebug()->TRACE_BUFFER("SR", pBuffer, ReadAtLeast);
        
        return static_cast<bool>(Stream);
    }
    
    
    LinuxSerialSocket::ReadCallbackFunction LinuxSerialSocket::RegisterReadHandler(ReadCallbackFunction Callback)
    {
        ReadCallbackFunction RetVal = m_Read;
        m_Read = Callback;
        return RetVal;
    }
    
    ERROR_TYPE LinuxSerialSocket::Close()
    {
        m_Port.cancel();
        m_Port.close();
        OnClose(SUCCESSFUL);
        return SUCCESSFUL;
    }
    
    LinuxSerialSocket::CloseCallbackFunction LinuxSerialSocket::RegisterCloseHandler(CloseCallbackFunction Callback)
    {
        CloseCallbackFunction RetVal = m_Close;
        m_Close = Callback;
        return RetVal;
    }

    bool LinuxSerialSocket::IsConnected()
    {
        return m_Port.is_open();
    }

    ERROR_TYPE LinuxSerialSocket::Flush(FlushDirection Direction)
    {
        const int FLUSHES[] = { TCIFLUSH, TCOFLUSH, TCIOFLUSH };
        ::tcflush(m_Port.lowest_layer().native_handle(), FLUSHES[Direction]);
        return SUCCESSFUL;
    }
    
    ERROR_TYPE LinuxSerialSocket::SetOptions(const ISerial::Options& Opt)
    {
        m_Options = Opt;
        return SUCCESSFUL;
    }
    
    void LinuxSerialSocket::SetPortOptions()
    {
        const uint32_t BAUDS[] = 
        {
            300,
            600,
            1200,
            1800,
            2400,
            4800,
            9600,
            19200,
            38400,
            57600,
            115200,
            230400,
            460800,
            500000,
            576000,
            921600,
            1152000,
            1500000,
            2000000,
            2500000,
            3000000,
            3500000,
            4000000
        };
        asio::serial_port_base::parity::type PARITIES[] =
        { 
            asio::serial_port_base::parity::type::none,
            asio::serial_port_base::parity::type::even,
            asio::serial_port_base::parity::type::odd
        };
        asio::serial_port_base::stop_bits::type STOPBITS[] =
        { 
            asio::serial_port_base::stop_bits::type::one,
            asio::serial_port_base::stop_bits::type::onepointfive,
            asio::serial_port_base::stop_bits::type::two
        };

        m_Port.set_option(asio::serial_port_base::baud_rate(BAUDS[m_Options.m_BaudRate]));
        m_Port.set_option(asio::serial_port_base::character_size(m_Options.m_CharacterSize));
        m_Port.set_option(asio::serial_port_base::parity(PARITIES[m_Options.m_Parity]));
        m_Port.set_option(asio::serial_port_base::stop_bits(STOPBITS[m_Options.m_StopBits]));
        m_Port.set_option(asio::serial_port_base::flow_control(asio::serial_port_base::flow_control::none));
    }   

    void LinuxSerialSocket::OnClose(ERROR_TYPE Error)
    {
        if (m_Close)
        {
            m_Close(Error);
        }
    }

}
