// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#include <termios.h>
#include <chrono>
#include <iostream>
#include <iomanip>
#include <string>

#include "optional.h"
#include "LinuxSocket.h"
#include "IBaseLibrary.h"
#include "IDebug.h"

namespace EPRI
{
    using namespace asio::ip;
    //
    // LinuxIP
    //
    LinuxIP::LinuxIP(asio::io_service& IO) :
        m_IO(IO)
    {
    }
    
    LinuxIP::~LinuxIP()
    {
    }
        
    ISocket * LinuxIP::CreateSocket(const IIP::Options& Opt)
    {
        return &(*m_TCPSockets.emplace(m_TCPSockets.begin(), Opt, m_IO));
    }
    
    void LinuxIP::ReleaseSocket(ISocket * pSocket)
    {
        pSocket->Close();
        //
        // Post to allow socket cleanup befor removal.
        //
        m_IO.post(std::bind(&LinuxIP::RemoveSocket, this, pSocket));
    }
    
    bool LinuxIP::Process()
    {
        return true;
    }

    void LinuxIP::RemoveSocket(ISocket * pSocket)
    {
        m_TCPSockets.remove_if(
            [pSocket](const LinuxTCPSocket& Socket)
            {
                return &Socket == pSocket;
            });
    }
    //
    // LinuxTCPSocket
    //
    LinuxTCPSocket::LinuxTCPSocket(const IIP::Options& Opt, asio::io_service& IO):
        m_Options(Opt), m_Acceptor(IO), m_Socket(IO), m_Resolver(IO)
    {
    }
    
    LinuxTCPSocket::~LinuxTCPSocket()
    {
    }
    
    void LinuxTCPSocket::ASIO_Accept_Handler(const asio::error_code& Error)
    {
        if (m_Connect)
        {
            Base()->GetDebug()->TRACE("\n\nConnection from %s...\n\n", 
                m_Socket.remote_endpoint().address().to_string().c_str());
            
            m_Connect(Error ? !SUCCESSFUL : SUCCESSFUL);
        }
    }
    
    void LinuxTCPSocket::ASIO_Resolver_Handler(const asio::error_code& Error, asio::ip::tcp::resolver::iterator it)
    {
        if (!Error)
        {
            tcp::endpoint Endpoint = *it;
            m_Socket.async_connect(Endpoint, 
                std::bind(&LinuxTCPSocket::ASIO_Connect_Handler, this, std::placeholders::_1, ++it));
        }
    }

    void LinuxTCPSocket::ASIO_Connect_Handler(const asio::error_code& Error, asio::ip::tcp::resolver::iterator it)
    {
        if (!Error && m_Connect)
        {
            Base()->GetDebug()->TRACE("\n\nConnected to %s...\n\n",  
                m_Socket.remote_endpoint().address().to_string().c_str());
            m_Connect(SUCCESSFUL);
        }
        else if (it != tcp::resolver::iterator())
        {
            m_Socket.close();
            tcp::endpoint Endpoint = *it;
            m_Socket.async_connect(Endpoint, 
                std::bind(&LinuxTCPSocket::ASIO_Connect_Handler, this, std::placeholders::_1, ++it));
            
        }
    }

    void LinuxTCPSocket::ASIO_Write_Handler(const asio::error_code& Error, size_t BytesTransferred)
    {
        //
        // Handle TCP Disconnection
        //
        if ((asio::error::eof == Error) ||
            (asio::error::connection_reset == Error) ||
            (asio::error::operation_aborted == Error))
        {
            if (m_Close)
            {
                m_Close(SUCCESSFUL);
            }
        }
        else if (m_Write)
        {
            m_Write(Error || !m_Socket.is_open() ? !SUCCESSFUL : SUCCESSFUL, BytesTransferred);
        }
    }
    
    void LinuxTCPSocket::ASIO_Read_Handler(const asio::error_code& Error, size_t BytesTransferred)
    {
        //
        // Handle TCP Disconnection
        //
        if ((asio::error::eof == Error) ||
            (asio::error::connection_reset == Error) ||
            (asio::error::operation_aborted == Error))
        {
            if (m_Close)
            {
                m_Close(SUCCESSFUL);
            }
        }
        else if (m_Read)
        {
            m_Read(Error ? !SUCCESSFUL : SUCCESSFUL, BytesTransferred);
        }
    }

    ERROR_TYPE LinuxTCPSocket::Open(const char * DestinationAddress /*= nullptr*/, int Port /*= DEFAULT_DLMS_PORT*/)
    {
        try
        {
            if (m_Options.m_Mode == IIP::Options::MODE_SERVER)
            {
                tcp::endpoint EndPoint = tcp::endpoint(m_Options.m_IPVersion == IIP::Options::VERSION4 ?  tcp::v4() : tcp::v6(), 
                    Port);
                m_Acceptor.open(EndPoint.protocol());
                m_Acceptor.set_option(tcp::acceptor::reuse_address(m_Options.m_ReuseAddress));
                m_Acceptor.bind(EndPoint);
                m_Acceptor.listen();
                m_Acceptor.async_accept(m_Socket, 
                    std::bind(&LinuxTCPSocket::ASIO_Accept_Handler, this, std::placeholders::_1));
            }
            else 
            {
                //
                // PRECONDITIONS
                //
                if (nullptr == DestinationAddress)
                {
                    return !SUCCESSFUL;
                }
                tcp::resolver::query    Query(DestinationAddress, std::to_string(Port));
                
                m_Socket.close();
                m_Resolver.async_resolve(Query, 
                    std::bind(&LinuxTCPSocket::ASIO_Resolver_Handler, this, std::placeholders::_1, std::placeholders::_2));
            }
		
        }
        catch (...)
        {
            return !SUCCESSFUL;
        }
        return SUCCESSFUL;
    }
    
    LinuxTCPSocket::ConnectCallbackFunction LinuxTCPSocket::RegisterConnectHandler(ConnectCallbackFunction Callback)
    {
        ConnectCallbackFunction RetVal = m_Connect;
        m_Connect = Callback;
        return RetVal;
    }
    
    IIP::Options LinuxTCPSocket::GetOptions()
    {
        return m_Options;
    }
    
    ERROR_TYPE LinuxTCPSocket::Write(const DLMSVector& Data, bool Asynchronous /*= false*/)
    {
        asio::error_code SocketError;
        ERROR_TYPE       RetVal = SUCCESSFUL;

        Base()->GetDebug()->TRACE_VECTOR("IW", Data);
        
        if (Asynchronous)
        {
            if (m_Write)
            {
                asio::async_write(m_Socket, asio::buffer(Data.GetBytes()), 
                    std::bind(&LinuxTCPSocket::ASIO_Write_Handler, this, std::placeholders::_1, std::placeholders::_2));
            }
        }
        else
        {
            asio::write(m_Socket, asio::buffer(Data.GetBytes()), asio::transfer_all(), SocketError);
            if (SocketError)
            {
                RetVal = !SUCCESSFUL;
            }
        }
        return RetVal;
    }
    
    LinuxTCPSocket::WriteCallbackFunction LinuxTCPSocket::RegisterWriteHandler(WriteCallbackFunction Callback)
    {
        WriteCallbackFunction RetVal = m_Write;
        m_Write = Callback;
        return RetVal;
    }
    
    ERROR_TYPE LinuxTCPSocket::Read(DLMSVector * pData,
        size_t ReadAtLeast /*= 0*/,
        uint32_t TimeOutInMS /*= 0*/,
        size_t * pActualBytes /*= nullptr*/)
    {
        ERROR_TYPE       RetVal = SUCCESSFUL;
        
        if (!pData /* Asynchronous */)
        {
            asio::async_read(m_Socket,
                m_ReadBuffer,
                asio::transfer_exactly(ReadAtLeast ? ReadAtLeast : 1), 
                std::bind(&LinuxTCPSocket::ASIO_Read_Handler, this, std::placeholders::_1, std::placeholders::_2));
        }
        else
        {
            size_t           ActualBytes = m_Socket.available();
            if (0 == ActualBytes)
            {
                return !SUCCESSFUL;
            }
            asio::error_code ErrorCode;
            uint8_t *        pAppend = &(*pData)[pData->AppendExtra(ActualBytes)];

            ActualBytes = m_Socket.read_some(asio::buffer(pAppend, ActualBytes), ErrorCode);
            //
            // Handle TCP Disconnection
            //
            if ((asio::error::eof == ErrorCode) ||
                (asio::error::connection_reset == ErrorCode))
            {
                if (m_Close)
                {
                    m_Close(SUCCESSFUL);
                }
            }
            else if (ErrorCode)
            {
                RetVal = !SUCCESSFUL;
            }
            if (ActualBytes)
            {
                Base()->GetDebug()->TRACE_BUFFER("IR", pAppend, ActualBytes);
            }
            if (pActualBytes)
            {
                *pActualBytes = ActualBytes;
            }
        }
        return RetVal;  
    }

    bool LinuxTCPSocket::AppendAsyncReadResult(DLMSVector * pData, size_t ReadAtLeast /*= 0*/)
    {
        std::istream Stream(&m_ReadBuffer);
        if (0 == ReadAtLeast)
        {
            Stream.seekg(0, Stream.end);
            ReadAtLeast = Stream.tellg();
            Stream.seekg(0, Stream.beg);
        }
        uint8_t * pBuffer = &(*pData)[pData->AppendExtra(ReadAtLeast)];
        Stream.read((char *)pBuffer, ReadAtLeast);

        Base()->GetDebug()->TRACE_BUFFER("IR", pBuffer, ReadAtLeast);
        
        return static_cast<bool>(Stream);
    }
    
    
    LinuxTCPSocket::ReadCallbackFunction LinuxTCPSocket::RegisterReadHandler(ReadCallbackFunction Callback)
    {
        ReadCallbackFunction RetVal = m_Read;
        m_Read = Callback;
        return RetVal;
    }
    
    ERROR_TYPE LinuxTCPSocket::Close()
    {
        m_Socket.close();
        return SUCCESSFUL;
    }
    
    LinuxTCPSocket::CloseCallbackFunction LinuxTCPSocket::RegisterCloseHandler(CloseCallbackFunction Callback)
    {
        CloseCallbackFunction RetVal = m_Close;
        m_Close = Callback;
        return RetVal;
    }

    bool LinuxTCPSocket::IsConnected()
    {
        return m_Socket.is_open();
    }

}
