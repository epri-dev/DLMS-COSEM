// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#include "COSEM.h"
#include "APDU/APDUDefs.h"

namespace EPRI
{
    //
    // APPOpenRequestOrIndication
    //
    APPOpenRequestOrIndication::APPOpenRequestOrIndication(AARQ * pAARQ) :
        APPBaseCallbackParameter(pAARQ->GetSourceAddress(), pAARQ->GetDestinationAddress())
    {
        ASNType::GetNextResult RetVal;
        //
        // Application Context is Required
        //
        RetVal = pAARQ->application_context_name.GetNextValue(&m_SecurityOptions.ApplicationContextName);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED)
        {
            throw std::logic_error("application_context_name Required");
        }
        //
        // Mechanism is Optional
        //
        RetVal = pAARQ->mechanism_name.GetNextValue(&m_SecurityOptions.MechanismName);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("mechanism_name Invalid");
        }
        //
        // Sender ACSE Requirements is Optional
        //
        DLMSValue RequestValue;
        RetVal = pAARQ->sender_acse_requirements.GetNextValue(&RequestValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("sender_acse_requirements Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal &&
                 DLMSValueGet<DLMSBitSet>(RequestValue)[0])
        {
            RetVal = pAARQ->calling_authentication_value.GetNextValue(&m_SecurityOptions.AuthenticationValue);
            if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED)
            {
                throw std::logic_error("Authentication is Required");
            }
        }
        //
        // xDLMS Context is Optional
        //
        RetVal = pAARQ->user_information.GetNextValue(&RequestValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("user_information Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal)
        {
            if (!m_xDLMS.Parse(&DLMSValueGet<DLMSVector>(RequestValue)))
            {
                throw std::logic_error("xDLMS Context Invalid");
            }
        }
    } 
    
    bool APPOpenRequestOrIndication::ToAPDU(AARQ * pAARQ)
    {
        //
        // PRECONDITIONS
        //
        // ApplicationContext is the only required parameter
        //
        if (m_SecurityOptions.ApplicationContextName.IsEmpty())
        {
            return false;
        }
        bool RetVal = pAARQ->application_context_name.Append(m_SecurityOptions.ApplicationContextName) &&
                      pAARQ->mechanism_name.Append(m_SecurityOptions.MechanismName);
        if (m_SecurityOptions.Authentication())
        {
            RetVal = RetVal &&
                pAARQ->sender_acse_requirements.Append(ASNBitString(1, m_SecurityOptions.Authentication() ? 1 : 0)) &&
                pAARQ->calling_authentication_value.SelectChoice(m_SecurityOptions.AuthenticationType()) &&
                pAARQ->calling_authentication_value.Append(m_SecurityOptions.AuthenticationValue);
        }
        if (m_xDLMS.Initialized())
        {
            RetVal = RetVal &&
                pAARQ->user_information.Append(m_xDLMS.GetBytes());    
        }
        return RetVal;
    }
    //
    // APPOpenConfirmOrResponse
    //
    APPOpenConfirmOrResponse::APPOpenConfirmOrResponse(AARE * pAARE)
        : APPBaseCallbackParameter(pAARE->GetSourceAddress(), pAARE->GetDestinationAddress())
    {
        ASNType::GetNextResult RetVal;
        //
        // Application Context is Required
        //
        RetVal = pAARE->application_context_name.GetNextValue(&m_SecurityOptions.ApplicationContextName);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED)
        {
            throw std::logic_error("application_context_name Required");
        }
        //
        // Mechanism is Optional
        //
        RetVal = pAARE->mechanism_name.GetNextValue(&m_SecurityOptions.MechanismName);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("mechanism_name Invalid");
        }
        //
        // Sender ACSE Requirements is Optional
        //
        DLMSValue RequestValue;
        RetVal = pAARE->responder_acse_requirements.GetNextValue(&RequestValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("responder_acse_requirements Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal &&
                 DLMSValueGet<DLMSBitSet>(RequestValue)[0])
        {
            RetVal = pAARE->responding_authentication_value.GetNextValue(&m_SecurityOptions.AuthenticationValue);
            if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED)
            {
                throw std::logic_error("Authentication is Required");
            }
        }
        //
        // xDLMS Context is Optional
        //
        RetVal = pAARE->user_information.GetNextValue(&RequestValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("user_information Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal)
        {
            if (!m_xDLMS.Parse(&DLMSValueGet<DLMSVector>(RequestValue)))
            {
                throw std::logic_error("xDLMS Context Invalid");
            }
        }        
        //
        // Result and Diagnostics are Required
        //
        if (ASNType::GetNextResult::VALUE_RETRIEVED == pAARE->result.GetNextValue(&RequestValue) &&
            IsVariant(RequestValue))
        {
            m_Result = (AssociationResultType) DLMSValueGet<int8_t>(RequestValue);
        }
        if (ASNType::GetNextResult::VALUE_RETRIEVED == pAARE->result_source_diagnostic.GetNextValue(&RequestValue) &&
            IsVariant(RequestValue) && pAARE->result_source_diagnostic.GetChoice((int8_t *) &m_DiagnosticSource))
        {
            m_Diagnostic = DLMSValueGet<int8_t>(RequestValue);
        }
    }
    
    bool APPOpenConfirmOrResponse::ToAPDU(AARE * pAARE)
    {
        //
        // PRECONDITIONS
        //
        if (m_SecurityOptions.ApplicationContextName.IsEmpty())
        {
            return false;
        }
        bool RetVal = pAARE->application_context_name.Append(m_SecurityOptions.ApplicationContextName) &&
            pAARE->result.Append(int8_t(m_Result)) &&
            pAARE->result_source_diagnostic.SelectChoice(m_DiagnosticSource) &&
            pAARE->result_source_diagnostic.Append(m_Diagnostic);
        if (m_xDLMS.Initialized())
        {
            RetVal = RetVal &&
                pAARE->user_information.Append(m_xDLMS.GetBytes());    
        }
        return RetVal;
    }
    //
    // APPReleaseRequestOrIndication
    //
    APPReleaseRequestOrIndication::APPReleaseRequestOrIndication(RLRQ * pRLRQ)
        : APPBaseCallbackParameter(pRLRQ->GetSourceAddress(), pRLRQ->GetDestinationAddress())
    {
        ASNType::GetNextResult RetVal;
        DLMSValue              RequestValue;
        //
        // Release Request Reason is Optional
        //
        RetVal = pRLRQ->reason.GetNextValue(&RequestValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("reason Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal)
        {
            m_Reason = ReleaseReason(DLMSValueGet<int8_t>(RequestValue));
        }
        //
        // xDLMS Context is Optional
        //
        RetVal = pRLRQ->user_information.GetNextValue(&RequestValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("user_information Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal)
        {
            if (!m_xDLMS.Parse(&DLMSValueGet<DLMSVector>(RequestValue)))
            {
                throw std::logic_error("xDLMS Context Invalid");
            }
        }        
    }
    
    bool APPReleaseRequestOrIndication::ToAPDU(RLRQ * pRLRQ)
    {
        bool RetVal = true;
        if (m_Reason)
        {
            RetVal = pRLRQ->reason.Append((int8_t)m_Reason.value());
        }
        if (m_xDLMS.Initialized())
        {
            RetVal = RetVal &&
                pRLRQ->user_information.Append(m_xDLMS.GetBytes());    
        }
        return RetVal;
    }
    //
    // APPReleaseConfirmOrResponse
    //
    APPReleaseConfirmOrResponse::APPReleaseConfirmOrResponse(RLRE * pRLRE)
        : APPBaseCallbackParameter(pRLRE->GetSourceAddress(), pRLRE->GetDestinationAddress())
    {
        ASNType::GetNextResult RetVal;
        DLMSValue              ResponseValue;
        //
        // Release Request Reason is Required
        //
        RetVal = pRLRE->reason.GetNextValue(&ResponseValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("reason Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal)
        {
            m_Reason = ReleaseReason(DLMSValueGet<int8_t>(ResponseValue));
        }
        //
        // xDLMS Context is Optional
        //
        RetVal = pRLRE->user_information.GetNextValue(&ResponseValue);
        if (RetVal != ASNType::GetNextResult::VALUE_RETRIEVED &&
            RetVal != ASNType::GetNextResult::VALUE_EMPTY)
        {
            throw std::logic_error("user_information Invalid");
        }
        else if (ASNType::GetNextResult::VALUE_RETRIEVED == RetVal)
        {
            if (!m_xDLMS.Parse(&DLMSValueGet<DLMSVector>(ResponseValue)))
            {
                throw std::logic_error("xDLMS Context Invalid");
            }
        }        
    }
    
    bool APPReleaseConfirmOrResponse::ToAPDU(RLRE * pRLRE)
    {
        bool RetVal = true;
        if (m_Reason)
        {
            RetVal = pRLRE->reason.Append(int8_t(m_Reason.value()));
        }
        if (m_xDLMS.Initialized())
        {
            RetVal = RetVal &&
                pRLRE->user_information.Append(m_xDLMS.GetBytes());    
        }
        return RetVal;
    }
    //
    // COSEM
    //
    COSEM::COSEM(COSEMAddressType Address) :
        StateMachine(ST_MAX_STATES),
        m_Address(Address)
    {
        //
        // State Machine
        //
        BEGIN_STATE_MAP
            STATE_MAP_ENTRY(ST_INACTIVE, COSEM::ST_Inactive_Handler)
            STATE_MAP_ENTRY(ST_IDLE, COSEM::ST_Idle_Handler)
            STATE_MAP_ENTRY(ST_ASSOCIATION_PENDING, COSEM::ST_Association_Pending_Handler)
            STATE_MAP_ENTRY(ST_ASSOCIATION_RELEASE_PENDING, COSEM::ST_Association_Release_Pending_Handler)
            STATE_MAP_ENTRY(ST_ASSOCIATED, COSEM::ST_Associated_Handler)
        END_STATE_MAP
    }
    
    COSEM::~COSEM()
    {
    }
    	
    COSEM::TRANSPORT_HANDLE COSEM::RegisterTransport(Transport * pXPort)
    {
        static TRANSPORT_HANDLE HANDLE_COUNTER = 0;
        if (m_Transports.size() == MaxTransports())
        {
            return -1;
        }
        ++HANDLE_COUNTER;
        m_Transports[HANDLE_COUNTER] = pXPort;
        
        pXPort->RegisterTransportEventHandler(m_Address,
            std::bind(&COSEM::TransportEventHandler, this, std::placeholders::_1));
        //
        // APDU Handler Registration
        //
        pXPort->RegisterAPDUHandler(m_Address, AARQ::Tag,
            std::bind(&COSEM::AARQ_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, AARE::Tag,
            std::bind(&COSEM::AARE_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, Get_Request_Base::Tag,
            std::bind(&COSEM::GET_Request_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, Get_Response_Base::Tag,
            std::bind(&COSEM::GET_Response_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, Set_Request_Base::Tag,
            std::bind(&COSEM::SET_Request_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, Set_Response_Base::Tag,
            std::bind(&COSEM::SET_Response_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, Action_Request_Base::Tag,
            std::bind(&COSEM::ACTION_Request_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, Action_Response_Base::Tag,
            std::bind(&COSEM::ACTION_Response_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, RLRQ::Tag,
            std::bind(&COSEM::RLRQ_Handler, this, std::placeholders::_1));
        pXPort->RegisterAPDUHandler(m_Address, RLRE::Tag,
            std::bind(&COSEM::RLRE_Handler, this, std::placeholders::_1));
        
        return HANDLE_COUNTER;
    }
    
    bool COSEM::IsOpen() const
    {
        return m_CurrentState == ST_ASSOCIATED;
    }
    
    COSEMAddressType COSEM::GetAddress() const
    {
        return m_Address;
    }

    size_t COSEM::MaxTransports()
    {
        return 1;
    }
    
    bool COSEM::TransportEventHandler(const Transport::TransportEvent& Event)
    {
        if (ST_INACTIVE == m_CurrentState && Transport::TRANSPORT_CONNECTED == Event)
        {
            return ExternalEvent(ST_IDLE, new TransportEventData(Event));
        }
        else if (Transport::TRANSPORT_DISCONNECTED == Event)
        {
            return ExternalEvent(ST_INACTIVE, new TransportEventData(Event));
        }
        return false;
    }
    //
    // COSEM-ABORT Service
    //
    void COSEM::RegisterAbortIndication(CallbackFunction Callback)
    {
        RegisterCallback(APPAbortIndication::ID, Callback);
    }
    //
    // HELPERS
    //
    Transport * COSEM::GetTransport() const
    {
        if (m_Transports.empty())
        {
            return nullptr;
        }
        return m_Transports.begin()->second;
    }

}