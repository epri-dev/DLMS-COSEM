// ===========================================================================
// Copyright (c) 2018, Electric Power Research Institute (EPRI)
// All rights reserved.
//
// DLMS-COSEM ("this software") is licensed under BSD 3-Clause license.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
// *  Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// *  Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// *  Neither the name of EPRI nor the names of its contributors may
//    be used to endorse or promote products derived from this software without
//    specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//
// This EPRI software incorporates work covered by the following copyright and permission
// notices. You may not use these works except in compliance with their respective
// licenses, which are provided below.
//
// These works are provided by the copyright holders and contributors "as is" and any express or
// implied warranties, including, but not limited to, the implied warranties of merchantability
// and fitness for a particular purpose are disclaimed.
//
// This software relies on the following libraries and licenses:
//
// ###########################################################################
// Boost Software License, Version 1.0
// ###########################################################################
//
// * asio v1.10.8 (https://sourceforge.net/projects/asio/files/)
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// 

#include "IBaseLibrary.h"
#include "IDebug.h"
#include "COSEMEngine.h"
#include "COSEMDevice.h"
#include "Transport.h"

namespace EPRI
{

#define MAKE_TOKEN(SERVICE, INVOKEID)\
    ((SERVICE << 8) | INVOKEID)
    //
    // COSEMEngine
    //
    bool COSEMEngine::IsTransportConnected() const
    {
        return m_pTransport->IsConnected();
    }
    //
    // COSEMClientEngine
    //
    COSEMClientEngine::COSEMClientEngine(const Options& Opt, Transport * pXPort) :
        COSEMEngine(pXPort), m_Client(Opt.m_Address), m_Options(Opt)
    {
        m_Client.RegisterTransport(pXPort);
        m_Client.RegisterOpenConfirm(
            std::bind(&COSEMClientEngine::Client_OpenConfirmation, this, std::placeholders::_1));
        m_Client.RegisterGetConfirm(
            std::bind(&COSEMClientEngine::Client_GetConfirmation, this, std::placeholders::_1));
        m_Client.RegisterSetConfirm(
            std::bind(&COSEMClientEngine::Client_SetConfirmation, this, std::placeholders::_1));
        m_Client.RegisterActionConfirm(
            std::bind(&COSEMClientEngine::Client_ActionConfirmation, this, std::placeholders::_1));
        m_Client.RegisterReleaseConfirm(
            std::bind(&COSEMClientEngine::Client_ReleaseConfirmation, this, std::placeholders::_1));
        m_Client.RegisterAbortIndication(
            std::bind(&COSEMClientEngine::Client_AbortIndication, this, std::placeholders::_1));
    }
    
    COSEMClientEngine::~COSEMClientEngine()
    {
    }
    
    bool COSEMClientEngine::Process()
    {
        return true;
    }
    //
    // COSEM.Open Service
    //
    bool COSEMClientEngine::Open(COSEMAddressType DestinationAddress, const COSEMSecurityOptions& Security,
                                 const xDLMS::InitiateRequest& xDLMS)
    {
        return m_Client.OpenRequest(APPOpenRequestOrIndication(m_Options.m_Address, DestinationAddress, 
                                                               xDLMS, Security));
    }
    
    bool COSEMClientEngine::OnOpenConfirmation(COSEMAddressType /*ServerAddress*/)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }

    bool COSEMClientEngine::IsOpen() const
    {
        return m_Client.IsOpen();
    }
    //
    // COSEM.Get Service
    //
    bool COSEMClientEngine::Get(const Cosem_Attribute_Descriptor& Descriptor,
                                RequestToken * pToken)
    {
        bool                    RetVal = m_Client.IsOpen();
        if (RetVal)
        {
            RetVal = m_Client.GetRequest(
                           APPGetRequestOrIndication(m_Options.m_Address,
                                                     m_Client.GetAssociatedAddress(),
                                                     CurrentInvokeID(SERVICE_GET), 
                                                     COSEMPriority::COSEM_PRIORITY_NORMAL,
                                                     COSEMServiceClass::COSEM_SERVICE_CONFIRMED,
                                                     Descriptor));
           
        }
        if (RetVal)
        {
            *pToken = MAKE_TOKEN(SERVICE_GET,
                                 GetAndIncrementInvokeID(SERVICE_GET));
            m_Responses.emplace(std::make_pair(*pToken, GetResponse(Descriptor)));
        }
        return RetVal;
    }
    
    bool COSEMClientEngine::OnGetConfirmation(RequestToken Token, const GetResponse& Response)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // COSEM.Set Service
    //
    bool COSEMClientEngine::Set(const Cosem_Attribute_Descriptor& Descriptor,
                                const DLMSVector& Value,
                                RequestToken * pToken)    
    {
        bool RetVal = m_Client.IsOpen();
        if (RetVal)
        {
            RetVal = m_Client.SetRequest(
                           APPSetRequestOrIndication(m_Options.m_Address,
                                m_Client.GetAssociatedAddress(),
                                CurrentInvokeID(SERVICE_SET), 
                                COSEMPriority::COSEM_PRIORITY_NORMAL,
                                COSEMServiceClass::COSEM_SERVICE_CONFIRMED,
                                Descriptor,
                                Value));
           
        }
        if (RetVal)
        {
            *pToken = MAKE_TOKEN(SERVICE_SET,
                                 GetAndIncrementInvokeID(SERVICE_SET));
            m_Responses.emplace(std::make_pair(*pToken, SetResponse(Descriptor)));
        }
        return RetVal;
    }
    
    bool COSEMClientEngine::OnSetConfirmation(RequestToken Token, const SetResponse& Response)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }    
    //
    // COSEM.Action Service
    //
    bool COSEMClientEngine::Action(const Cosem_Method_Descriptor& Descriptor,
        const DLMSOptional<DLMSVector>& Parameters,
        RequestToken * pToken)    
    {
        bool RetVal = m_Client.IsOpen();
        if (RetVal)
        {
            RetVal = m_Client.ActionRequest(
                           APPActionRequestOrIndication(m_Options.m_Address,
                                m_Client.GetAssociatedAddress(),
                                CurrentInvokeID(SERVICE_SET), 
                                COSEMPriority::COSEM_PRIORITY_NORMAL,
                                COSEMServiceClass::COSEM_SERVICE_CONFIRMED,
                                Descriptor,
                                Parameters));
           
        }
        if (RetVal)
        {
            *pToken = MAKE_TOKEN(SERVICE_ACTION,
                                 GetAndIncrementInvokeID(SERVICE_ACTION));
            m_Responses.emplace(std::make_pair(*pToken, ActionResponse(Descriptor)));
        }
        return RetVal;
    }
    
    bool COSEMClientEngine::OnActionConfirmation(RequestToken Token, const ActionResponse& Response)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    } 
    //
    // COSEM.Release Service
    //
    bool COSEMClientEngine::Release(const xDLMS::InitiateRequest& xDLMS, bool UseRLRE /* = true */)
    {
        if (m_Client.IsOpen())
        {
            m_Client.ReleaseRequest(
                APPReleaseRequestOrIndication(m_Options.m_Address,
                    m_Client.GetAssociatedAddress(),
                    xDLMS,
                    UseRLRE));
        }
        return true;    
    }
    
    bool COSEMClientEngine::OnReleaseConfirmation(COSEMAddressType /*ServerAddress*/)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // COSEM.Abort Service
    //
    bool COSEMClientEngine::OnAbortIndication(COSEMAddressType /*ServerAddress*/)
    {
        //
        // Default Handler Does Nothing
        //
        return true;
    }
    //
    // Protected Methods
    //
    InvokeIdAndPriorityType COSEMClientEngine::CurrentInvokeID(ServiceID Service) const
    {
        return m_InvokeID[Service];
    }
    
    InvokeIdAndPriorityType COSEMClientEngine::GetAndIncrementInvokeID(ServiceID Service)
    {
        return m_InvokeID[Service]++;
    }
    
    bool COSEMClientEngine::Client_OpenConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPOpenConfirmOrResponse& Confirmation = 
            dynamic_cast<const APPOpenConfirmOrResponse&>(Parameters);
        return OnOpenConfirmation(Confirmation.m_SourceAddress);
    }
    
    bool COSEMClientEngine::Client_GetConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPGetConfirmOrResponse& Confirmation = dynamic_cast<const APPGetConfirmOrResponse&>(Parameters);
        RequestToken                   Token = MAKE_TOKEN(SERVICE_GET, 
                                                          COSEM_GET_INVOKE_ID(Confirmation.m_InvokeIDAndPriority));
        try
        {
            GetResponse& Response = PickupResponse<GetResponse>(Token);
            Response.Result = Confirmation.m_Result;
            Response.ResultValid = true;
            
            return OnGetConfirmation(Token, Response);
        }
        catch (...)
        {
        }
        return false;        
    }

    bool COSEMClientEngine::Client_SetConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPSetConfirmOrResponse& Confirmation = dynamic_cast<const APPSetConfirmOrResponse&>(Parameters);
        RequestToken                   Token = MAKE_TOKEN(SERVICE_SET, 
                                                          COSEM_GET_INVOKE_ID(Confirmation.m_InvokeIDAndPriority));
        try
        {
            SetResponse& Response = PickupResponse<SetResponse>(Token);
            Response.Result = Confirmation.m_Result;
            Response.ResultValid = true;
            
            return OnSetConfirmation(Token, Response);
        }
        catch (...)
        {
        }
        return false;        
    }

    bool COSEMClientEngine::Client_ActionConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPActionConfirmOrResponse& Confirmation = dynamic_cast<const APPActionConfirmOrResponse&>(Parameters);
        RequestToken                   Token = MAKE_TOKEN(SERVICE_ACTION, 
                                                          COSEM_GET_INVOKE_ID(Confirmation.m_InvokeIDAndPriority));
        try
        {
            ActionResponse& Response = PickupResponse<ActionResponse>(Token);
            Response.Result = Confirmation.m_Result;
            Response.ResultValid = true;
            
            return OnActionConfirmation(Token, Response);
        }
        catch (...)
        {
        }
        return false;        
        
    }
    
    bool COSEMClientEngine::Client_ReleaseConfirmation(const BaseCallbackParameter& Parameters)
    {
        const APPReleaseConfirmOrResponse& Confirmation = dynamic_cast<const APPReleaseConfirmOrResponse&>(Parameters);
        return OnReleaseConfirmation(Confirmation.m_SourceAddress);
    }
    
    bool COSEMClientEngine::Client_AbortIndication(const BaseCallbackParameter& Parameters)
    {
        const APPAbortIndication& Indication = dynamic_cast<const APPAbortIndication&>(Parameters);
        return OnAbortIndication(Indication.m_SourceAddress);
    }
    //
    // COSEMServerEngine
    //
    COSEMServerEngine::COSEMServerEngine(const Options& Opt, Transport * pXPort) :
        COSEMEngine(pXPort), m_Options(Opt)
    {
    }
    
    COSEMServerEngine::~COSEMServerEngine()
    {
    }

    bool COSEMServerEngine::Process()
    {
        return m_pTransport->Process();
    }
    
    void COSEMServerEngine::RegisterDevice(COSEMDevice * pDevice)
    {
        pDevice->RegisterTransport(m_pTransport);
        m_Devices.push_back(pDevice);
    }
    
    void COSEMServerEngine::UnregisterDevice(COSEMDevice * pDevice)
    {
        m_Devices.remove(pDevice);
    }
    
}